---
layout: post
title:  "What You Dee is What You Get - Building a Verifiable Enclave Image"
date:   "2024-03-03"
author: Richard Fan
toc:    true
---

![Cover Image](/assets/images/8734c91a-5130-4590-88b7-b93684affa4a.jpg){:style="display:none"}

**Link to the GitHub Action discussed in this post**: [https://github.com/marketplace/actions/aws-nitro-enclaves-eif-build-action](https://github.com/marketplace/actions/aws-nitro-enclaves-eif-build-action){:target="_blank"}

---
AWS Nitro Enclaves is a Trusted Execution Environment (TEE) where service consumers can validate if the environment is running what it claims to be running.

I've posted previously on how to achieve it by using attestation documents and why should we care about the content of the attestation document:

* [How to Use AWS Nitro Enclaves Attestation Document](/2020/11/22/how-to-use-aws-nitro-enclaves-attestation-documenta.html){:target="_blank"}
* [AWS Nitro Enclaves Ecosystem (1) - Chain of trust](/2022/12/22/aws-nitro-enclaves-ecosystem-1-chain-of-trust.html){:target="_blank"}

In this blog post, I want to dive deep into achieving zero-trust between service providers and consumers on TEE, particularly AWS Nitro Enclaves.

## Obstacle of proofing TEE

### Image digest is meaningless

Platform configuration registers (PCRs) are just the application image digests; they are generated by a one-way hashing function against the image.

We cannot see what is inside the image by looking at the hash value. So **without knowing what generated the PCRs, it's meaningless**.

For service consumers who have no oversight of the application source code and build process, they have nothing to do, even if they can validate the attestation document. They can only trust whoever saying **"This PCR value 'abcdef' is generated by a secure and safe application"**

Service providers may ask 3rd party auditor to attest the above statement. But it's no different than getting SOC2 or ISO 27001 certified.

**If we are satisfied with this level of trust model, we can stop talking about TEE already. Why don't we send the SOC2 certificate to the consumers instead of the attestation document?**

### Stable image digest is difficult

If service consumers can access the application source code and the build pipeline definition, they may build the enclave image and compare the digest with the one provided in the attestation document.

The problem is that generating a stable image digest is difficult, **even a small trivial difference occurs in build time can make the digest entirely different**.

![Build time difference can make the PCR value different](/assets/images/d6ecba66-0607-4d84-b9f2-405005ced8e0.jpg)

Some common trivial changes in build time are:

1. **Timestamp**

    Some build steps inject the current timestamp into the environment (e.g. [embedded timestamp in `.pyc` files when installing Python dependencies](https://github.com/pypa/pip/issues/5648#issuecomment-410446975){:target="_blank"}).

    This makes the resulting image dependent on the time of build.

1. **External dependencies**

    Even if we pin all dependencies to the exact version, using external sources may still cause image differences.

    E.g., when running `apt update` on Ubuntu, the manifest pulled from an external source may be different than previously pulled.

1. **Other build time randomness**

    There are more examples that can cause image differences.

    E.g., Using random strings as temporary folder names.

By looking at the image digest difference, **we cannot tell if it's caused by trivial differences or service provider changing their source code**.

## Solution - Trusted build pipeline

To avoid the hiccup of creating a reproducible build process, we can instead **create a trust build pipeline that service consumers can see and trust**.

To make it work on AWS Nitro Enclaves images, I have created a GitHub action [AWS Nitro Enclaves EIF Build Action](https://github.com/marketplace/actions/aws-nitro-enclaves-eif-build-action){:target="_blank"}

[![Using GitHub and SigStore to achieve trusted build pipeline](/assets/images/8734c91a-5130-4590-88b7-b93684affa4a.jpg)](/assets/images/8734c91a-5130-4590-88b7-b93684affa4a.jpg){:target="_blank"}

### GitHub provides the service suite we need

To achieve an end-to-end chain of trust from source code, build process, to the resulting enclave image, we need a publicly accessible and trusted code repository, build environment, and artifact store.

Undoubtedly, GitHub is currently the most popular platform to host open-source code. GitHub also provides GitHub Actions as the build environment and GitHub Packages as the artifact store.

**By putting the entire build pipeline into GitHub, we can minimize the number of parties we build trust into.**

### Use SigStore to sign and endorse the image

The other main component of the solution is SigStore.

[SigStore](https://www.sigstore.dev/){:target="_blank"} is a set of open-source technologies to handle the digital signing of software.

Using SigStore, we can easily sign the enclave image and prove to the public that this image is built by a specific pipeline run, from a particular code repository commit.

### Putting everything together

In this [sample repository](https://github.com/richardfan1126/nitro-enclaves-cosign-sandbox){:target="_blank"}, I use the **AWS Nitro Enclaves EIF Build Action** to build a Nitro Enclave image from the source code.

After the artifacts are built and pushed to the GitHub Container Registry (GHCR), there will be a `cosign` command to sign the artifact.

![Use cosign to sign the artifact](/assets/images/c53c4a6b-b2c1-4e3e-aa26-f6b0720cdf36.png)

Several things are happening behind this command:

1. The OIDC token of the GitHub workflow run is used to request a signing certificate from Fulcio

1. The digest of the uploaded artifacts (In this scenario, the Nitro Enclave EIF and its information) is signed

1. The signature is pushed to the artifact store (i.e., GHCR)

1. The signing certificate and the artifact signature are recorded in the Rekor transparency log

### How can service consumers verify the PCRs

Service consumers can audit the code once the artifact is signed and pushed to the registry.

To verify the PCRs they get from the attestation document are **indeed the same as what was built by the said build pipeline**, they can do the following:

1. Use `cosign` to verify the artifact against the signature stored in Rekor

    ```bash
    cosign verify ghcr.io/username/repo:tag \
        --certificate-identity-regexp https://github.com/<username>/<repo>/ \
        --certificate-oidc-issuer https://token.actions.githubusercontent.com
    ```

    ![Use cosign to verify artifact signature](/assets/images/12a8d843-4622-4056-ac48-e728b579ba70.png)

1. Validate the information on the signing certificate

    User can search the signing entry on [Rekor Search](https://search.sigstore.dev/){:target="_blank"} by its log index

    ![Rekor search](/assets/images/d3dd1538-bba7-4d7a-8442-68469caad1fd.png)

    ![Rekor search](/assets/images/c3779cbb-86f3-4aef-92da-4030d0ccaa48.png)

    **We should look carefully at the following attributes**:

    * **OIDC Issuer**: The token must be issued by the trusted build environment.
    
        (In this example, it must be the GitHub Actions OIDC issuer `https://token.actions.githubusercontent.com`)

    * **GitHub Workflow SHA**: This indicates which particular Git commit the build pipeline run is from.

        This helps us identify from which commit we should look at when auditing the source code.

    * **Build Config URI**: This file defines the build workflow.
    
        We should also check if the build configuration is safe, just like how we audit the application code.

    * **Runner Environment**: We should also ensure the build was run on GitHub-hosted runners instead of self-hosted ones that cannot be trusted.

1. Audit the code based on the information on the certificate

    After knowing how the artifact was built, we can go to the specific commit of the code repository to audit the codes.

1. Pull the artifact and get the PCRs

    After all the validation, we can use [ORAS](https://oras.land/){:target="_blank"} to pull the EIF and its information.

    The PCR values are inside the signed text file; they can be compared with the ones given by the attestation document from the running service.

    ```bash
    oras pull ghcr.io/username/repo:tag@sha256:<digest>
    ```

    ![Use ORAS to pull the artifact](/assets/images/f25adb11-ac30-4cc4-820e-e7ee75e61cb4.png)

## What's beyond

### Build log retention

GitHub actions run on public repositories can be viewed by anyone; it gives service consumers **more confidence in the enclave application by looking into how exactly it was built**.

However, the GitHub action log can only be retained for up to 90 days.

If the service consumers want utmost scrutiny over the enclave application, service providers may need to rebuild the enclave image every 90 days so that **build logs can be audited at any point in time**.

### Build pipeline still needs to be simple

Although service consumers can audit the build process in this design, it doesn't mean service providers don't need to make their build process simple.

**The more complex a build pipeline is, the more difficult it can be to understand what's being done under the hood**.

E.g., If the build pipeline pulled source codes from an external source instead of the source code repository; How can we see, from the build log, what the content of those codes is?

## Wrap up

Three years after AWS announced Nitro Enclaves, the support from AWS is still minimal. _(Sidetrack: My [PR](https://github.com/aws/aws-nitro-enclaves-sdk-c/pull/132){:target="_blank"} on `kmstool` is still pending for review)_

There is still little to no discussion on how to utilize Nitro Enclaves to achieve TEE in the real world. I hope the tools I build can at least offer some help to the community.

**Link to the GitHub Action**: [https://github.com/marketplace/actions/aws-nitro-enclaves-eif-build-action](https://github.com/marketplace/actions/aws-nitro-enclaves-eif-build-action){:target="_blank"}
